#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

#include "proxy.h"


char *encode_hex(char *key, int key_sz) {
	const char int_to_hex[] = "0123456789ABCDEF";
	static char hex[512 + 2];
	if(NEVER(key_sz > 256)) {
		log_error("broken key_sz %i", key_sz);
		key_sz = 256;
	}
	char *p = hex;
	while(key_sz) {
		*p++ = int_to_hex[((*key) >> 4) & 0xF];
		*p++ = int_to_hex[(*key) & 0xF] ;
		
		key++;
		key_sz--;
	}
	*p = '\0';
	return(hex);
}

int decode_hex(char **key_ptr, int *key_sz_ptr, char *hex) {
	const int hex_to_int[256] = { ['0'] 0,   ['1'] 1,   ['2'] 2,   ['3'] 3,
				['4'] 4,   ['5'] 5,   ['6'] 6,   ['7'] 7,
				['8'] 8,   ['9'] 9,   ['A'] 10,  ['B'] 11,
				['C'] 12,  ['D'] 13,  ['E'] 14,  ['F'] 15 };
	static char start_key[256];
	char *key = start_key;
	char *end_key = key + sizeof(key);
	
	if(hex == NULL) {
		*key_sz_ptr = 0;
		return(0);
	}
	
	while(*hex && *(hex+1)) {
		if(key >= end_key) {
			return(-1);
		}
		int a = hex_to_int[(int)*(hex+0)];
		int b = hex_to_int[(int)*(hex+1)];
		if((a == 0 && *(hex+0) != '0') || (b == 0 && *(hex+1) != '0')) {
			return(-1);
		}
		*key++ = (a << 4) | b;
		hex += 2;
	}
	if(*hex) {
		return(-1);
	}
	*key_ptr = start_key;
	*key_sz_ptr = key - start_key;
	return(0);
}


int split_line(char ***argv_ptr, char *line, char *sep_chars, char *quit_chars) {
	char *argv[32];
	*argv_ptr = argv;
	int argc = 0;
	char *line_end = line + strlen(line);
	char sep[256] = {0};
	while(*sep_chars) {
		int p = *sep_chars++;
		sep[p] = 1;
	}
	while(*quit_chars) {
		int p = *quit_chars++;
		sep[p] = 2;
	}
	
	char prev = 0;
	for(; line < line_end; line++) {
		switch(sep[(int)*line]) {
		case 1:
			*line = '\0'; // inplace
			break;
		case 2:
			*line = '\0';
			goto done;
			break;
		}
		if(!prev && *line) { // new block
			argv[argc++] = line;
			if(argc == (NELEM(argv)-1)) // one slot for null
				break;
		}
		prev = *line;
	}
done:
	argv[argc] = NULL;
	return(argc);
}

int get_host_port(char **host_ptr, int *port_ptr, char *line) {
	char **argv;
	int argc = split_line(&argv, line, ":", "");
	if(argc != 2)
		return(-1);
	*host_ptr = argv[0];
	*port_ptr = atoi(argv[1]);
	if(*port_ptr < 1 || *port_ptr > 65535)
		return(-2);
	return(0);
}

#define LINE_LENGTH 1024

void load_config(struct config *config) {
	FILE *fd;
	int servers=0;
	int proxies=0;
	
	fd = fopen(config->config_path, "r");
	if(NULL == fd) {
		fatal("Can't read config file \"%s\".", config->config_path);
	}
	
	char *host, *key;
	int port, key_sz;
	char line[LINE_LENGTH];
	int line_no = 0;
	while(NULL != fgets(line, sizeof(line), fd)) {
		line_no ++;
		char **argv;
		int argc;
		argc = split_line(&argv, line, " ,\t\n\r", "#");
		if(argc == 0)
			continue;
		if(0 == strcmp(argv[0], "proxy")) {
			if(argc != 1+1)
				fatal("Expected exactly one argument on line %i", line_no);
			if(0 != get_host_port(&host, &port, argv[1]))
				fatal("Bad host description or port number on line %i", line_no);
			if(-1 == new_st_proxy(config, host, port))
				fatal("duplicate proxy in line %i", line_no);
			proxies++;
		}else
		if(0 == strcmp(argv[0], "server")) {
			if(argc != 3+1 && argc != 2+1)
				fatal("Expected two or three arguments on line %i", line_no);
			if(0 != get_host_port(&host, &port, argv[1]))
				fatal("Bad host description or port number on line %i", line_no);
			int weight = atoi(argv[2]);
			if(weight < 1 || weight > 999999)
				fatal("Broken weight value of %i on line %i", weight, line_no);
			if(argc == 3+1) {
				if(0 != decode_hex(&key, &key_sz, argv[3]))
					fatal("Broken key value on line %i", line_no);
			} else {
				key = "";
				key_sz = 0;
			}
			if(-1 == new_st_server(config, host, port, weight, key, key_sz))
				fatal("duplicate server in line %i", line_no);
			servers++;
		} else {
			fatal("Unrecognized keyword \"%s\" on line %i", argv[0], line_no);
		}
	}
	fclose(fd);
	if(!proxies)
		fatal("No proxies defined in config, not even myself!\n"
			"Are you sure it's a correct autogenerated file?");
	if(!servers)
		fatal("No servers defined in config. It's broken!");
}

int write_line(FILE *fd, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));
int write_line(FILE *fd, const char *fmt, ...) {
	char line[1024];
	
	va_list ap;
	va_start(ap, fmt);
	vsnprintf(line, sizeof(line), fmt, ap);
	va_end(ap);

	int r = fputs(line, fd);
	if(r == EOF)
		return(-1);
	return(0);
}

char *strip(char *s) {
	char replace_chars[256] = {
		['\n']	1,
		['\r']	1,
		['\t']	1,
		[' ']	1
	};
		
	while(replace_chars[(int)*s])
		s++;
	int len = strlen(s);
	while(len > 0 && replace_chars[len-1]) {
		s[len-1] = '\0';
		len--;
	}
	return(s);
}


int save_config(struct config *config) {
	FILE *fd;
	int r = 0;
	fd = fopen(config->config_path_new, "w");
	if(NULL == fd) {
		log_error("Can't write to config file \"%s\".", config->config_path_new);
		return(-1);
	}
	r = write_line(fd, "# This file is automatically generated. Do not edit.\n");
	if(r) goto error;
	char hostname[256];
	gethostname(hostname, sizeof(hostname));
	time_t now = time(NULL);
	r = write_line(fd, "#Created on %s, %s\n", strip(ctime(&now)), hostname);
	if(r) goto error;
	
	write_line(fd, "\n");
	struct rb_node *node = rb_first(&config->proxies);
	while(node) {
		struct st_proxy *proxy = container_of(node, struct st_proxy, node);
		node = rb_next(node);
		r = write_line(fd, "proxy\t%s:%i\n", proxy->host, proxy->port);
		if(r) goto error;
	}
	
	write_line(fd, "\n");
	node = rb_first(&config->servers);
	while(node) {
		struct st_server *server = container_of(node, struct st_server, node);
		node = rb_next(node);
		r = write_line(fd, "server\t%s:%i, %i, %s\n",
					server->host, server->port,
					server->weight,
					encode_hex(server->key, server->key_sz));
		if(r) goto error;
	}
	
error:;
	fclose(fd);
	log_error("Can't write to config file \"%s\".", config->config_path_new);
	return(-1);
}


